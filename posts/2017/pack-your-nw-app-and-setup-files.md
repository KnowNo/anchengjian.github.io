# 打包NW.js应用和制作windows安装文件

本文适应有一定 js 基础，但第一次玩 windows 下 setup 打包的同学，默认的环境 windows。   

## 一、折腾能力强，直接上文档   
1. [How-to-package-and-distribute-your-apps](https://github.com/nwjs/nw.js/wiki/How-to-package-and-distribute-your-apps)
2. [setup-on-windows](https://github.com/nwjs/nw.js/wiki/How-to-package-and-distribute-your-apps#setup-on-windows)

这部分没啥好说的，都很简单。   

对新手友好。。。还有个 NW.js 的打包在 gayhub 上还专门有个 npm 包 [nw-builder](https://github.com/nwjs/nw-builder) ，这个用起来就更简单了，我连示例都不想写的那种简单。然后这儿需要下载 NW.js 的 SDK 或者 NORMAL 的包，方法同我上一篇文章 [用 vue2 和 webpack 快速建构 NW.js 项目](http://anchengjian.com/#/posts/2017/vuejs-webpack-nwjs.md) 中 `网络不太好` 部分   

## 二、自助打包
NW.js 被打包出来后是一个文件夹，里面有整个 runtimes 和一个 exe 文件，这时候整个打包就成功了，差不多有 100MB 左右。  
但是，我们的应用不再是给内部使用，给用户下载总不能直接给用户拷贝一个文件夹或者下载 zip 压缩包，那样忒不靠谱的样子，还以为是啥病毒呢。  

我们能不能就像吃自助餐那样，想吃啥就拿啥，想打包成啥样就弄成啥样。  

**当然可以** 整体思路就是自己搞一个 runtime，然后用 Node.js 对打包好的代码进行 zip 压缩为 `package.nw`，然后放到 runtime 中，再用官方推荐的 InnoSetup 来打包成一个 setup.exe。

### 1. XP 兼容性问题
使用 NW.js 的主要优势是兼容 XP，教育行业这个真的很重要呀。。。   
NW.js 不是全版本都支持 XP，由于 Chromium50 开始就不支持XP了，所以如果你的客户端要支持 XP，目前最佳的版本选择是 `0.14.7` 。参见 NW.js 的博客 [NW.js v0.14.7 (LTS) Released](https://nwjs.io/blog/v0.14.7/)

### 2. 制作一个自己的  runtime
从官网 [http://dl.nwjs.io/v0.14.7/](http://dl.nwjs.io/v0.14.7/) 下载一个 normal 的包，然后在此基础上进行 DIY。  

大概目录就是这样子
![原始runtime](/posts/assets/imgs/nw/nwjs-v0.14.7-dir.jpg)

然后就开始优化和自定义工作：  

1) 先整理下 locales 下的语言包，减少部分冗余。  

2) 替换下 [ffmpeg.dll](https://github.com/iteufel/nwjs-ffmpeg-prebuilt/releases) 解决部分格式 video 的播放问题等，下载的时候注意下版本，和 NW.js 相对应就好。

3) 将 `nw.exe` 改名字为我们的应用的名字，比如`myProgramApp.exe`，更正规一点。然后用 `Resource Hacker` 修改下版本和版权公司等相关信息。

4) 再用使用 `Resource Hacker` 进行图标替换，建议尺寸是256。

5) 同时为其添加管理员权限。因为我们要做增量更新，需要用 Node.js 写文件到应用所在目录，当安装目录是 `C:\Program Files\` 的时候，普通权限用户没有写权限。  
具体操作还是用 `Resource Hacker` 打开`myProgramApp.exe`，找到 `Manifest`中
```
<requestedExecutionLevel level="asInvoker" uiAccess="false"/></requestedPrivileges>
```
修改为
```
<requestedExecutionLevel level="requireAdministrator" uiAccess="false"/></requestedPrivileges>
```

弄完了大概是这个样子
![DIY完成的runtime](/posts/assets/imgs/nw/nwjs-v0.14.7-diy-dir.jpg)

### 3. 用 Node.js 打包 `package.nw`
需要一个 zip 处理的依赖 [archiver](https://github.com/archiverjs/node-archiver)，第一次用这个依赖，建议直接去看他们的英文文档，谨慎使用 `bulk` 这个方法，在 0.21.0 的时候就被废弃了。  
打包 zip 的方法大概就长这样：
``` javascript
const fs = require('fs')
const archive = require('archive')

function buildZipFile({ outZipPath, files, mainPackage } = {}) {
  let filesArr = Array.isArray(files) ? files : [files]

  // 创建一个可写流的 zip 文件
  var output = fs.createWriteStream(outZipPath)
  var archive = archiver('zip', { store: true })

  archive.on('error', console.error)

  // 打包 dist 目录为 zip 压缩包格式的 nw 文件
  archive.pipe(output)

  if (filesArr.length > 0) {
    filesArr.forEach(p => {
      if (!p) return

      // 剔除 package.json
      let hasPackJson = path.resolve(p, 'package.json')
      if (fs.existsSync(hasPackJson)) fs.unlinkSync(hasPackJson)

      // 压缩目录
      archive.directory(p, '')
    })

    // 添加 package.json
    archive.file(mainPackage, { name: 'package.json' })
  }

  archive.finalize()
}
```

### 4. InnoSetup 打包安装包
Node.js 的丰富的生态已经有人提供了一个 [node-innosetup-compiler](https://github.com/felicienfrancois/node-innosetup-compiler) 了，所以这个也很方便。不过对于我这种第一次玩这个的玩家还是有点懵逼，特别是那个 `iss` 文件的编写。。。

鉴于本文不想写成 InnoSetup 的使用教程，所以只讲讲普通使用，如果你需要更复杂的功能,给你个文档 [Inno Setup Help](http://www.jrsoftware.org/ishelp/index.php?topic=setup_defaultdirname)   

我提供一个我用的 `setup.iss ` 文件，其中用下划线开头（如: _appName ）这种将会被 js 正则匹配掉
```
; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
; 该执行目录为 setup.iss 所在的目录，请注意拼接相对目录

#define MyAppName "_appName"
#define MyAppNameZh "_appZhName"
#define MyAppVersion "_appVersion"
#define MyAppPublisher "_appPublisher"
#define MyAppURL "_appURL"
#define MyAppExeName "_appName.exe"
#define OutputPath "_appOutputPath"
#define SourceMain "_appRuntimePath\_appName.exe"
#define SourceFolder "_appRuntimePath\*"
#define LicenseFilePath "_appResourcesPath\license.txt"
#define SetupIconFilePath "_appResourcesPath\_appName.ico"
#define MyAppId "_appId"

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={#MyAppId}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppVerName={#MyAppName}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={pf}\{#MyAppName}
LicenseFile={#LicenseFilePath}
OutputDir={#OutputPath}
OutputBaseFilename={#MyAppName}-v{#MyAppVersion}-setup
SetupIconFile={#SetupIconFilePath}
Compression=lzma
SolidCompression=yes
PrivilegesRequired=admin
Uninstallable=yes
UninstallDisplayName={#MyAppNameZh}
DefaultGroupName={#MyAppNameZh}

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: checkedonce

[Files]
Source: {#SourceMain}; DestDir: "{app}"; Flags: ignoreversion
Source: {#SourceFolder}; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs

[Icons]
Name: "{commondesktop}\{#MyAppNameZh}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon
Name: "{group}\{#MyAppNameZh}"; Filename: "{app}\{#MyAppExeName}"
Name: "{group}\卸载{#MyAppNameZh}"; Filename: "{uninstallexe}"

[Languages]
Name: "chinese"; MessagesFile: "innosetup\Languages\ChineseSimp.isl"

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent
```

创建一个 resources 文件夹，里面放上 icon 和 license，就像这样
![resources目录](/posts/assets/imgs/nw/nw-resources-dir.jpg)

再然后此 iss 配合 `makeExeSetup` 使用，格外酸爽，请忽略那一串 replace，233333333  
``` javascript
function makeExeSetup(opt) {
  const { issPath, outputPath, mainPackage, runtimePath, resourcesPath, appPublisher, appURL, appId } = opt
  const { name, appName, version } = require(mainPackage)
  const tmpIssPath = path.resolve(path.parse(issPath).dir, '_tmp.iss')
  const innosetupCompiler = require('innosetup-compiler')

  // rewrite name, version to iss
  fs.readFile(issPath, null, (err, text) => {
    if (err) throw err

    let str = iconv.decode(text, 'gbk')
      .replace(/_appName/g, name)
      .replace(/_appZhName/g, appName)
      .replace(/_appVersion/g, version)
      .replace(/_appOutputPath/g, outputPath)
      .replace(/_appRuntimePath/g, runtimePath)
      .replace(/_appResourcesPath/g, resourcesPath)
      .replace(/_appPublisher/g, appPublisher)
      .replace(/_appURL/g, appURL)
      .replace(/_appId/g, appId)


    fs.writeFile(tmpIssPath, iconv.encode(str, 'gbk'), null, err => {
      if (err) throw err

      // inno setup start
      innosetupCompiler(tmpIssPath, { gui: false, verbose: true }, function(err) {
        fs.unlinkSync(tmpIssPath)
        if (err) throw err
      })
    })
  })
}
```

这个时候就能制作出一个安装包了，就像这样
![安装包](/posts/assets/imgs/nw/doudou-setup.jpg)

然后是安装的流程
![安装流程](/posts/assets/imgs/nw/install.gif)

安装完成的目录
![安装完成的目录](/posts/assets/imgs/nw/install-dir.jpg)

## 三、炫酷的安装界面
虽然 InnoSetup 简单好使，但是制作出来的安装包的安装界面默认是 windows2000 的界面，那个丑那个老旧哟。。。   

如果你的应用只要能用就行了，那这一步已经完全够了。   
但技术人怎么能不折腾，下面，我们来搞炫酷的安装包的制作方法。   

先摆一个被我模仿的例子 [INNOSETUP 仿有道云安装包界面](http://blog.csdn.net/HarounCloud/article/details/50613590) 

## 四、应用的更新

